# 이름 짓는 규칙(Naming Conventions)

## 명명 형식(Naming Styles)

- `b`: 소문자 한 글자
- `B`: 대문자 한 글자
- `lowercase`
- `lower_case_with_underscores`
- `UPPERCASE`
- `UPPER_CASE_WITH_UNDERSCORES`
- `CapitalizedWords`(= CapWords = CamelCase = StudlyCaps)
  - CapWords에서 약어는 대문자: `HTTPServerError`
- `mixedCase`(첫 글자가 소문자)
- `Capitalized_Words_With_Underscores`(비추!)
- `st_mode`, `st_size`, `st_mtime`: 고유 접두사를 사용(파이썬에서 많이 사용하지 않음)
- `_single_leading_underscore`: 내부용으로 사용되는 변수 또는 함수를 표시할 때.
  - 외부에서 직접 접근하거나 사용하지 말 것을 권고하는 암묵적인 규칙.
  - 문법적으로 사용하지 못하도록 강제하지는 않는다.
  - `from M import *` 는 `_`로 시작하는 객체는 가져오지 않는다.
  - `import M`을 사용하면 `_`로 시작하는 변수나 함수를 접근할 수 있다.
- `single_trailing_underscore_`: 파이썬 키워드와의 충돌을 피하기 위해 관례적으로 사용. 
  - 예: `tkinter.Toplevel(master, class_='ClassName')`
- `__double_leading_underscore`: 클래스 속성의 이름
- `__double_leading_and_trailing_underscore__`: "magic objects" 또는 "magic attributes" 에서 사용.
  - 파이썬에서 특별한 동작을 하도록 설계된 객체나 속성: __init__, __import__, __file__
  - 이런 식으로 이름을 짓지 말라!

## 명명 규칙(Naming Conventions)

- 피해야 할 이름
  - l, o, I 는 숫자 1, 0과 구별하기 힘들기 때문에 사용을 피하라.
- ASCII 호환성
  - 표준 라이브러리에서 사용되는 식별자는 PEP 3131 의 정책 섹션에 설명된 대로 ASCII 호환이어야 한다.
  - 즉 표준 라이브러리의 모든 식별자는 ASCII 문자로 작성하라.
  - 리터럴(literal)과 주석도 ACSII로 작성하라.
  - 단, 작성자 이름은 ASCII가 아닌 문자로 작성하더라도 읽을 수 있도록 라틴 문자로 표시해 줘야 한다.
- 패키지 및 모듈 이름
  - 모듈은 짧고 모두 소문자 이름을 가져야 한다.
  - 가독성을 위해 모듈 이름에 밑줄을 사용할 수 있다.
  - 파이썬 패키지 이름은 밑줄 사용이 권장되지 않는다.
  - C 또는 C++로 작성된 확장 모듈은 앞에 밑줄(예: `_socket`)을 붙인다.
- 클래스 이름
  - 클래스 이름은 일반적으로 CapWords 규칙을 사용해야 한다.
  - 인터페이스가 문서화되어 있고 주로 호출 가능한 객체로 사용되는 경우에는 함수의 명명 규칙을 대신 사용할 수 있다.
  - 내장 이름에는 별도의 규칙이 있다. 대부분의 내장 이름은 단일 단어(또는 함께 실행되는 두 단어)이다.
  - CapWords 규칙은 예외 이름과 내장 상수에만 사용된다.
- 타입 변수 이름
  - PEP 484 에 도입된 타입 변수의 이름은 일반적으로 CapWords 스타일의 짧은 이름을 사용한다
    - 예) `T`, `AnyStr`, `Num`. 
  - covariant 또는 contravariant의 동작을 선언할 때는 변수 접미사로 `_co` 또는 `_contra`를 붙인다.
```
from typing import TypeVar

VT_co = TypeVar('VT_co', covariant=True)
KT_contra = TypeVar('KT_contra', contravariant=True)
```
- 예외 이름
  - 예외는 클래스여야 하므로 클래스 명명 규칙을 따른다. 
  - 예외가 실제 오류인 경우 예외 이름에 접미사로 "Error"를 붙인다.
- 전역 변수 이름
  - 이러한 변수는 하나의 모듈 내부에서만 사용되는게 좋다.
  - 명명 규칙은 함수의 규칙과 같다.
  - `from M import *` 을 통해 모듈을 사용하도록 설계한 경우, 전역으로 노출되는 것을 막고 싶을 때
    - `__all__` list 메커니즘을 사용하거나
      - `from M import *`로 가져올 이름들을 명시적으로 지정할 수 있는 특별한 list 이다.
      - 이 list에 포함되지 않은 이름은 `from M import *`로 가져오지 못한다.
    - `_`로 이름을 시작한다. (`_`로 시작하는 이름의 변수나 함수, 객체는 가져오지 않기 때문)
- 함수 및 변수 이름
  - 함수 이름은 소문자여야 한다.
  - 가독성을 높이기 위해 필요에 따라 단어 사이를 밑줄로 구분할 수 있다.
  - 변수 이름
    - 함수 이름과 동일한 규칙을 따른다.
    - mixedCase는 이전 버전과의 호환성을 유지하기 위해 해당 스타일이 널리 사용되는 컨텍스트(예: threading.py)에서만 허용된다.
- 함수 및 메서드 인수
  - 인스턴스 메서드의 첫 번째 인수에는 항상 self를 사용한다.
  - 클래스 메서드의 첫 번째 인수에는 항상 cls를 사용한다.
  - 함수 인수의 이름이 예약 키워드와 충돌하는 경우, 
    - 일반적으로 약어나 철자 오류를 사용하는 것보다 하나의 꼬리 밑줄을 추가하는 것이 더 좋다. 
      - 즉 `clss` 보다 `class_`가 더 낫다.
    - 또는 동의어를 사용하여 이러한 충돌을 피하는 것이 더 낫다.
- 메서드 이름과 인스턴스 변수
  - 함수 명명 규칙을 사용한다.
    - 즉 가독성을 높이기 위해 필요에 따라 소문자로 쓰고 각 단어는 밑줄로 구분한다.
  - 비공개 메서드와 인스턴스 변수에는 하나의 밑줄만 사용한다.
  - 서브 클래스와의 이름 충돌을 피하려면,
    - 두 개의 밑줄을 사용하여 파이썬의 이름 변경 규칙(name mangling rules)을 적용한다.
    - 예) Foo 클래스에 __content 인스턴스 변수가 있다고 가정하자.
      - 클래스 내부: __content
      - 클래스 외부: Foo.__a (X), Foo._Foo__a (O) ==> 변수명 앞에 `_클래스명`이 붙는다.
    - 서브 클래스에서 같은 이름을 사용하더라도 충돌하지 않는다.
    - 서브 클래스와의 이름 충돌을 방지하기 위해서만 사용할 것. 남용하지 말 것.
    - `__이름` 방식으로 이름 짓는 부분에 대해 논란이 있음.
- 상수
  - 상수는 일반적으로 모듈 수준에서 정의된다.
  - 모두 대문자로 작성되며 밑줄로 단어를 구분한다. 
    - 예) `MAX_OVERFLOW`, `TOTAL`
- 상속을 고려한 설계
  - 클래스 속성(메서드와 인스턴스 변수)의 공개, 비공개 여부를 항상 결정하라. 
    - 모르겠으면 일단 비공개 하라. 
    - 나중에 공개 속성을 비공개로 만드는 것보다 비공개를 공개로 만드는 것이 더 쉽다.
  - 공개(public) 속성
    - 클래스 외부에서 자유롭게 접근 가능한 속성.
    - 클래스 사용자(client)가 이 속성을 안전하게 사용할 수 있다는 의미.
    - 이후 버전에서도 호환성을 유지하겠다는 개발자의 약속을 내포.
    - 호환성 보장: 공개 속성은 변경하거나 제거하면 사용 중인 코드에서 문제가 발생할 수 있기 때문.
    - 문서화 대상: 공개 속성은 API로 간주되어 용도와 사용법을 명확히 문서화 해야 한다.
  - 비공개(non-public) 속성
    - 클래스 내부에서만 사용할 목적으로 만든 속성이다.
    - 제3자(third parties; 클래스를 사용하는 외부 코드 또는 서브 클래스)에게 사용을 권장하지 않는다.
    - 필요에 따라 언제든 변경되거나 삭제될 수 있음을 암시한다.
    - 호환성 미보장: 외부에서 사용하지 않을 것을 가정하기 때문에 언제든 변경하거나 삭제할 수 있다.
    - 문서화 대상이 아님: API 문서에서 제외된다. 내부 구현 세부 사항으로 간주된다.
    - 관례적으로 보호 대상: 사용을 막을 수는 없지만, 관례적으로 외부 사용을 방지한다.
    - `private` 이라는 용어는 사용하지 않는다. Python에 `private` 문법이 없다.
  - Pythonic guidelines
    - 어떤 속성이 공개이고, 어떤 속성이 서브클래스 API의 일부이며, 어떤 속성이 실제로 기본 클래스에서만 사용되는지를 판단할 때
    - 공개 속성에는 앞에 밑줄이 없어야 한다.
    - 공개 속성 이름이 예약된 키워드와 충돌하는 경우 속성 이름에 하나의 후행 밑줄을 추가한다. 
      - 이는 약어나 잘못된 철자보다 바람직합니다. 
      - 그럼에도 불구하고 'cls'는 클래스로 알려진 모든 변수나 인수, 특히 클래스 메서드의 첫 번째 인수에 대한 선호되는 철자다.
      - 위에서 설명한 **함수 및 메서드 인수** 이름 짓는 규칙을 참조하라.
    - 간단한 공개 데이터 속성의 경우 복잡한 accessor/mutator 메서드 없이 속성 이름만 노출하는 것이 가장 좋다.
      - 나중에 기능을 추가해야 할 경우, Python에서는 property 데코레이터를 사용하면 된다.
      - 기존의 접근 방식(속성 이름)을 유지하면서 기능을 확장할 수 있다.
      - 이는 유연성과 확장성을 높이는 설계 방식이다.
    - accessor/mutator 또는 property 데코레이터를 사용할 때 주의점!
      - 기능적 동작에는 부작용(side-effects)이 없어야 한다.
      - 즉 속성 접근이나 변경할 때 외부 자원을 변경한다거나 파일 쓰기 등을 해서는 안된다.
      - 일시적으로 속성 값을 보관하는 캐싱(허용 가능한 부작용)은 상관없다.
      - 속성의 설계 목표는 단순하고 직관적인 사용과 예측 가능성을 유지하는 것이다.
      - 계산이 많이 필요한 연산에는 property를 사용하지 말라. 
        - property 데코레이터는 속성처럼 보이지만 실제 함수이다.
        - 따라서 property를 사용하는 caller 입장에서는 접근이 간단하고 빠른 동작일 것이라 가정한다.
        - 그런데 호출자의 기대와 달리 실제 동작 간에 불일치가 발생하여 성능이나 예기치 않은 문제가 발생할 수 있다.
    - 클래스를 상속 받을 수 있도록 설계했고 서브클래스에서 사용하지 않으려는 속성이 있는 경우, 
      - 두 개의 선행 밑줄과 후행 밑줄 없이 이름을 지정하라. 
      - 이렇게 하면 Python의 **name mangling** 알고리즘이 호출되어 클래스 이름이 속성 이름에 포함된다.
      - 서브클래스에서 실수로 같은 이름의 속성을 포함해도 이름 충돌이 일어나지 않는다.
      - 단 디버깅이나 `__getattr__()`를 사용할 때 불편할 수 있다.
      - 모든 사람이 **name mangling**을 좋아하는 것은 아니다. 
      - 실수로 이름이 충돌하는 것을 피해야 하는 필요성과 고급 호출자의 잠재적 사용 사이에서 균형을 고려하라.
  - 공개 및 내부 인터페이스
    - 이전 버전과의 호환성 보장은 공개 인터페이스에만 적용된다. 
    - 따라서 사용자가 공개 인터페이스와 내부 인터페이스를 명확하게 구별할 수 있는 것이 중요하다.
    - 문서화된 인터페이스는 공개된 것으로 간주된다. 
    - 문서화되지 않은 모든 인터페이스는 내부 인터페이스로 가정한다.
    - introspection 지원: 
      - 모듈은 `__all__` 리스트 속성을 사용하여 공개 API에서 이름을 명시적으로 선언한다. 
      - `__all__` 빈 목록으로 설정하면 모듈에 공개 API가 없음을 나타낸다.
      - `__all__`을 적절하게 설정 하더라도 내부 인터페이스(패키지, 모듈, 클래스, 함수, 속성 또는 기타 이름)는 여전히 하나의 밑줄로 시작하는 접두사를 사용해야 한다.
    - 패키지, 모듈 또는 클래스 등의 네임스페이스가 내부로 간주되는 경우, 해당 인터페이스도 내부로 간주된다.
    - 즉 해당 인터페이스는 패키지, 모듈 또는 클래스 내부에서만 사용됨을 의미한다.
    - 문서화 되지 않은 API를 `import 모듈`로 가져와서 사용하지 말라.
    - 문서화된 API는 `from 모듈 import 함수`로 가져와서 사용하라. 
    - 다만 os.path 처럼 공식적으로 문서화된 모듈을 사용할 때는 `import 모듈`을 통해 API를 사용해도 된다.
    - 또는 패키지의 `__init__.py` 파일에 명시적으로 공개된 하위 모듈의 함수는 `import 모듈`을 통해 사용할 수 있다.
  